#!/bin/bash
# Autofill forms via Apple Passwords (apw CLI)
# Usage:
#   keychain-login            # autofill first match
#   keychain-login --pick     # always show record selection
# Requirements: brew install bendews/homebrew-tap/apw && brew services start apw

set -euo pipefail

export PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:$PATH"

# ========== Configuration ==========
DEBUG_LOG="/tmp/keychain-login.log"
PICK_MODE=false
ATTEMPTED_AUTH=false

# ========== Logging utilities ==========
log() {
  local timestamp
  timestamp=$(date '+%Y-%m-%d %H:%M:%S')
  {
    printf '[%s] %s\n' "$timestamp" "$*"
  } >>"$DEBUG_LOG" 2>&1 || true
}

send_message() {
  local level="$1"
  shift
  local text="$*"
  local escaped
  escaped=$(printf '%s' "$text" | sed 's/\\/\\\\/g; s/"/\\"/g')
  printf 'message-%s "%s"\n' "$level" "$escaped" >>"$QUTE_FIFO"
}

die() {
  log "ERROR: $*"
  send_message error "$*"
  exit 1
}

# ========== Environment checks ==========
[[ -z "${QUTE_URL:-}" ]] || [[ -z "${QUTE_FIFO:-}" ]] && die "Must be run as qutebrowser userscript"

# Create log file if it doesn't exist
touch "$DEBUG_LOG" 2>/dev/null || true
log "========== New keychain-login session =========="
log "URL: $QUTE_URL"

# ========== Argument parsing ==========
while [[ $# -gt 0 ]]; do
  case "$1" in
  -p | --pick)
    PICK_MODE=true
    log "Enabled record selection mode (--pick)"
    ;;
  -h | --help)
    send_message info "Usage: keychain-login [--pick]"
    exit 0
    ;;
  *)
    die "Unknown argument: $1"
    ;;
  esac
  shift
done

# ========== Dependency checks ==========
for cmd in jq python3; do
  if ! command -v "$cmd" >/dev/null 2>&1; then
    die "Command '$cmd' not found. Install: brew install $cmd"
  fi
done

if [[ -n "${APW_BIN:-}" ]]; then
  [[ ! -x "$APW_BIN" ]] && die "Specified APW_BIN='$APW_BIN' is not executable"
else
  if ! command -v apw >/dev/null 2>&1; then
    die "Command 'apw' not found. Install: brew install bendews/homebrew-tap/apw && brew services start apw"
  fi
  APW_BIN="$(command -v apw)"
fi

log "Using apw: $APW_BIN"

# Check apw service
if ! pgrep -x "apw" >/dev/null 2>&1; then
  send_message warning "apw service not running. Start it: brew services start apw"
  log "WARNING: apw process not found via pgrep"
fi

# ========== Domain extraction ==========
DOMAIN=$(echo "$QUTE_URL" | sed -E 's|^https?://([^/]+).*|\1|' | sed 's/^www\.//')
DOMAIN_LOWER=$(printf '%s' "$DOMAIN" | tr '[:upper:]' '[:lower:]')

log "Extracted domain: $DOMAIN (lowercase: $DOMAIN_LOWER)"
send_message info "Apple Passwords: searching records for $DOMAIN"

# ========== Find Alacritty for auth window ==========
find_alacritty() {
  for path in "/opt/homebrew/bin/alacritty" "/usr/local/bin/alacritty"; do
    if [[ -x "$path" ]]; then
      printf '%s' "$path"
      return 0
    fi
  done
  if command -v alacritty >/dev/null 2>&1; then
    command -v alacritty
    return 0
  fi
  return 1
}

# ========== Launch apw auth window ==========
launch_apw_auth() {
  local alacritty_bin

  log "Attempting auth via apw auth"

  if ! alacritty_bin=$(find_alacritty); then
    log "Alacritty not found, running apw auth directly"
    "$APW_BIN" auth
    return $?
  fi

  log "Found Alacritty: $alacritty_bin"

  # Create temporary script for auth window
  local temp_script
  temp_script=$(mktemp /tmp/apw-auth.XXXXXX)

  if [[ -z "$temp_script" ]]; then
    log "ERROR: mktemp failed to create temp file"
    die "Failed to create temp file for auth"
  fi

  # IMPORTANT: heredoc WITHOUT quotes for variable interpolation
  cat >"$temp_script" <<AUTHSCRIPT
#!/bin/bash
set -euo pipefail

export PATH="$PATH"
export __CFBundleIdentifier="org.qutebrowser.qutebrowser"

CYAN='\033[0;36m'
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

echo -e "\${CYAN}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\${NC}"
echo -e "\${CYAN}‚ïë      Apple Passwords - Authorization           ‚ïë\${NC}"
echo -e "\${CYAN}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\${NC}"
echo ""
echo -e "\${YELLOW}Touch ID prompt will appear in a separate window.\${NC}"
echo -e "Enter confirmation code and press Enter."
echo ""

"$APW_BIN" auth
status=\$?

echo ""
if [[ \$status -eq 0 ]]; then
    echo -e "\${GREEN}‚úì Authorization completed successfully!\${NC}"
else
    echo -e "\${RED}‚úó apw auth returned error code: \$status\${NC}"
fi

echo ""
echo -e "\${YELLOW}Press Enter to close window...\${NC}"
read -r
exit \$status
AUTHSCRIPT

  chmod +x "$temp_script"
  log "Created temp auth script: $temp_script"

  # Launch Alacritty with auth window (synchronously, wait for completion)
  log "Launching Alacritty: $alacritty_bin"

  set +e
  "$alacritty_bin" \
    --title "Apple Passwords - Authorization" \
    --option window.dimensions.columns=50 \
    --option window.dimensions.lines=15 \
    --command "$temp_script" 2>>"$DEBUG_LOG"
  local exit_code=$?
  set -e

  log "Alacritty exited with code: $exit_code"
  rm -f "$temp_script"
  return $exit_code
}

# ========== Query password list via apw ==========
query_apw_list() {
  local domain="$1"
  local output status

  log "Request: apw pw list '$domain'"

  set +e
  output=$("$APW_BIN" pw list "$domain" 2>&1)
  local exit_code=$?
  set -e

  log "apw pw list exit code: $exit_code"
  log "apw pw list output: $output"

  # Check JSON status
  if ! status=$(printf '%s' "$output" | jq -r '.status // "unknown"' 2>/dev/null); then
    log "Failed to parse JSON from apw pw list"
    printf '%s' "$output"
    return "$exit_code"
  fi

  log "JSON status code: $status"

  case "$status" in
  0)
    # Success
    printf '%s' "$output"
    return 0
    ;;
  1)
    # Timeout - possibly previous auth session hung
    log "apw timeout (status=1) - previous auth session hung"
    die "apw timeout: previous auth session hung. Restart service: brew services restart apw"
    ;;
  3)
    # No records
    log "No records for domain $domain (status=3)"
    printf '%s' "$output"
    return 3
    ;;
  2 | 4 | 5 | 9)
    # Authorization required (9=missing encryption key, 2/4/5=unauthorized)
    log "Authorization required (status=$status)"

    if [[ $ATTEMPTED_AUTH == false ]]; then
      ATTEMPTED_AUTH=true
      send_message info "Authorization required..."

      if launch_apw_auth; then
        log "Auth successful, retrying apw pw list"
        sleep 1
        query_apw_list "$domain" # Recursive call after auth
        return $?
      else
        die "apw auth failed"
      fi
    else
      die "apw requires re-auth but already attempted"
    fi
    ;;
  *)
    local error_msg
    error_msg=$(printf '%s' "$output" | jq -r '.error // "apw error"' 2>/dev/null)
    log "apw pw list returned unknown status $status: $error_msg"
    die "apw: $error_msg"
    ;;
  esac
}

# ========== Get password via apw ==========
query_apw_get() {
  local service="$1"
  local username="${2:-}"
  local output status

  local cmd=("$APW_BIN" pw get "$service")
  [[ -n "$username" ]] && cmd+=("$username")

  log "Request: ${cmd[*]}"

  set +e
  output=$("${cmd[@]}" 2>&1)
  local exit_code=$?
  set -e

  log "apw pw get exit code: $exit_code"
  log "apw pw get output length: ${#output}"

  if ! status=$(printf '%s' "$output" | jq -r '.status // "unknown"' 2>/dev/null); then
    log "Failed to parse JSON from apw pw get"

    # If already attempted auth, error
    if [[ $ATTEMPTED_AUTH == true ]]; then
      die "apw pw get returned invalid JSON after authorization"
    fi

    # Try auth and retry
    ATTEMPTED_AUTH=true
    send_message info "Authorization required to get password..."
    if launch_apw_auth; then
      log "Auth successful, retrying apw pw get"
      sleep 1
      query_apw_get "$service" "$username"
      return $?
    else
      die "apw auth failed"
    fi
  fi

  log "JSON status code: $status"

  case "$status" in
  0)
    printf '%s' "$output"
    return 0
    ;;
  2 | 4 | 5 | 9)
    if [[ $ATTEMPTED_AUTH == false ]]; then
      ATTEMPTED_AUTH=true
      send_message info "Authorization required to get password..."
      if launch_apw_auth; then
        log "Auth successful, retrying apw pw get"
        sleep 1
        query_apw_get "$service" "$username"
        return $?
      else
        die "apw auth failed"
      fi
    else
      die "apw requires re-auth for get but already attempted"
    fi
    ;;
  *)
    local error_msg
    error_msg=$(printf '%s' "$output" | jq -r '.error // "Failed to get password"' 2>/dev/null)
    die "apw pw get: $error_msg (status=$status)"
    ;;
  esac
}

# ========== Get OTP via apw ==========
query_apw_otp() {
  local service="$1"
  local username="${2:-}"  # username not used but kept for compatibility
  local output status

  # IMPORTANT: apw otp get accepts only URL, WITHOUT username
  local cmd=("$APW_BIN" otp get "$service")

  log "OTP request: ${cmd[*]}"

  set +e
  output=$("${cmd[@]}" 2>&1)
  local exit_code=$?
  set -e

  log "apw otp get exit code: $exit_code"
  log "apw otp get output length: ${#output}"
  log "apw otp get raw output: $output"

  # Check JSON and status
  if ! status=$(printf '%s' "$output" | jq -r '.status // "unknown"' 2>/dev/null); then
    log "Failed to parse JSON from apw otp get (likely no OTP or auth needed)"
    log "apw otp get non-JSON output (first 200 chars): ${output:0:200}"
    # Not critical error - just no OTP
    printf '{"status":3,"error":"No OTP found"}'
    return 3
  fi

  log "JSON status code for OTP: $status"

  case "$status" in
  0)
    # OTP successfully retrieved
    printf '%s' "$output"
    return 0
    ;;
  3)
    # No OTP for this record (normal, not all records have OTP)
    log "No OTP for $service / $username (status=3)"
    printf '%s' "$output"
    return 3
    ;;
  *)
    # Any other error - just log and return "No OTP"
    local error_msg
    error_msg=$(printf '%s' "$output" | jq -r '.error // "apw otp error"' 2>/dev/null)
    log "apw otp get returned status $status: $error_msg (skipping OTP)"
    printf '{"status":3,"error":"No OTP found"}'
    return 3
    ;;
  esac
}

# ========== Detect form type on page ==========
detect_form_type() {
  local html_file="$QUTE_HTML"

  # Default initialization (if detection fails)
  HAS_PASSWORD="false"  # pragma: allowlist secret
  HAS_OTP="false"

  if [[ -z "$html_file" || ! -f "$html_file" ]]; then
    log "WARN: QUTE_HTML unavailable ($html_file), fallback to password+OTP"
    HAS_PASSWORD="true"  # pragma: allowlist secret
    HAS_OTP="true"
    return
  fi

  log "Analyzing form from $html_file"

  # Check password fields
  if grep -qiE 'type=["'"'"']?password["'"'"']?' "$html_file"; then
    HAS_PASSWORD="true"  # pragma: allowlist secret
    log "Found password field (type=password)"
  elif grep -qiE 'autocomplete=["'"'"']?(current-password|new-password)["'"'"']?' "$html_file"; then
    HAS_PASSWORD="true"  # pragma: allowlist secret
    log "Found password field (autocomplete)"
  fi

  # Check OTP fields (strict conditions to avoid CSRF tokens)
  if grep -qiE 'autocomplete=["'"'"']?one-time-code["'"'"']?' "$html_file"; then
    HAS_OTP="true"
    log "Found OTP field (autocomplete=one-time-code)"
  elif grep -qiE '<input[^>]*type=["'"'"']?(text|tel|number)["'"'"']?[^>]*name=["'"'"'][^"'"'"']*otp' "$html_file"; then
    HAS_OTP="true"
    log "Found OTP field (name=otp)"
  elif grep -qiE '<input[^>]*inputmode=["'"'"']?numeric["'"'"']?[^>]*name=["'"'"'][^"'"'"']*(code|verification)' "$html_file"; then
    HAS_OTP="true"
    log "Found OTP field (inputmode=numeric + code/verification)"
  elif grep -qiE '<input[^>]*type=["'"'"']?(text|tel)["'"'"']?[^>]*name=["'"'"'][^"'"'"']*(2fa|mfa|totp)' "$html_file"; then
    HAS_OTP="true"
    log "Found OTP field (2fa/mfa/totp)"
  fi

  # Fallback: if nothing found, request password
  if [[ "$HAS_PASSWORD" == "false" && "$HAS_OTP" == "false" ]]; then  # pragma: allowlist secret
    log "WARN: Fields not detected, fallback to password"
    HAS_PASSWORD="true"  # pragma: allowlist secret
  fi

  log "Form detection result: hasPassword=$HAS_PASSWORD, hasOTP=$HAS_OTP"
}

# ========== Select record via fzf (Nord theme) ==========
select_entry_fzf() {
  local domain="$1"
  shift
  local entries=("$@")

  # Check for fzf
  if ! command -v fzf >/dev/null 2>&1; then
    log "fzf not found, fallback to osascript"
    select_entry_osascript "$domain" "${entries[@]}"
    return $?
  fi

  # Find Alacritty
  local alacritty_bin
  if ! alacritty_bin=$(find_alacritty); then
    log "Alacritty not found, fallback to osascript"
    select_entry_osascript "$domain" "${entries[@]}"
    return $?
  fi

  log "Using fzf for record selection (Alacritty: $alacritty_bin)"

  # Preparing data in TSV format for fzf
  # Display format: username@service ‚Ä¢ label (if label != service)
  local fzf_input=""
  local display_to_entry=()

  for entry in "${entries[@]}"; do
    IFS=$'\t' read -r username service label _uuid <<<"$entry"

    # Build display string
    local display="${username}@${service}"
    [[ -n "$label" && "$label" != "$service" ]] && display="${display} ‚Ä¢ ${label}"

    # Save mapping display -> original entry
    display_to_entry+=("$display|$entry")

    # Add to fzf input (TSV: display<tab>username<tab>service<tab>label)
    fzf_input+="${display}"$'\t'"${username}"$'\t'"${service}"$'\t'"${label}"$'\n'
  done

  # Creating temp script for fzf window
  local temp_script
  temp_script=$(mktemp /tmp/fzf-select.XXXXXX)

  if [[ -z "$temp_script" ]]; then
    log "ERROR: mktemp failed to create temp file for fzf"
    select_entry_osascript "$domain" "${entries[@]}"
    return $?
  fi

  log "Created temp fzf script: $temp_script"

  # Script with Nord color scheme and preview
  cat >"$temp_script" <<'FZFSCRIPT'
#!/bin/bash
set -euo pipefail

export PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:$PATH"

# Nord theme colors for fzf
export FZF_DEFAULT_OPTS="
--ansi
--height=100%
--layout=reverse
--border=rounded
--border-label=' Apple Passwords - Select Record '
--border-label-pos=3
--prompt=' ‚ùØ '
--pointer='‚ñ∂'
--marker='‚úì'
--info=inline
--delimiter=$'\t'
--with-nth=1
--preview='echo -e \"‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ\n‚îÇ üë§ User: {2}\n‚îÇ üåê Domain: {3}\n‚îÇ üè∑Ô∏è  Label: {4}\n‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ\n\nPress Enter to select\nor Esc to cancel\"'
--preview-window=up:9:border-rounded:wrap
--color=fg:#e5e9f0,bg:#2e3440,hl:#88c0d0
--color=fg+:#e5e9f0,bg+:#3b4252,hl+:#88c0d0
--color=info:#81a1c1,prompt:#81a1c1,pointer:#88c0d0
--color=marker:#a3be8c,spinner:#81a1c1,header:#88c0d0
--color=border:#4c566a,label:#81a1c1
--color=preview-fg:#d8dee9,preview-bg:#2e3440
--color=preview-border:#4c566a
"

# Read TSV data from stdin and show fzf
result=$(cat | fzf)
exit_code=$?

if [[ $exit_code -eq 0 && -n "$result" ]]; then
  echo "$result"
  exit 0
elif [[ $exit_code -eq 130 ]]; then
  # Ctrl-C / Esc
  echo "__CANCELLED__"
  exit 0
else
  echo "__CANCELLED__"
  exit 1
fi
FZFSCRIPT

  chmod +x "$temp_script"

  # Launch Alacritty with fzf
  local selected
  set +e
  selected=$(printf '%s' "$fzf_input" | "$alacritty_bin" \
    --title "Apple Passwords - Select Record" \
    --option window.dimensions.columns=120 \
    --option window.dimensions.lines=25 \
    --command "$temp_script" 2>>"$DEBUG_LOG")
  local exit_code=$?
  set -e

  rm -f "$temp_script"

  if [[ $exit_code -ne 0 || "$selected" == "__CANCELLED__" || -z "$selected" ]]; then
    log "User cancelled fzf selection"
    printf '__CANCELLED__'
    return 0
  fi

  # selected contains full string with tabs: "display\tusername\tservice\tlabel"
  # Extract display (first field)
  local display_selected
  display_selected=$(echo "$selected" | cut -f1)

  log "Selected via fzf: $display_selected"

  # Find corresponding original entry
  for mapping in "${display_to_entry[@]}"; do
    local display_part="${mapping%%|*}"
    local entry_part="${mapping#*|}"

    if [[ "$display_part" == "$display_selected" ]]; then
      printf '%s' "$entry_part"
      return 0
    fi
  done

  # Fallback to first record if not found
  log "Match not found for fzf selection, using first record"
  printf '%s' "${entries[0]}"
}

# ========== Select record via osascript ==========
select_entry_osascript() {
  local domain="$1"
  shift
  local entries=("$@")

  local osa_list=""
  local first_item=""
  local displays=()
  local idx=0

  for entry in "${entries[@]}"; do
    IFS=$'\t' read -r username service label _uuid <<<"$entry"

    local display="${username}@${service}"
    [[ -n "$label" && "$label" != "$service" ]] && display="${display} (${label})"

    displays+=("$display")

    local escaped
    escaped=$(printf '%s' "$display" | sed 's/\\/\\\\/g; s/"/\\"/g')
    osa_list+="\"$escaped\""

    if [[ $idx -lt $((${#entries[@]} - 1)) ]]; then
      osa_list+=", "
    fi

    [[ $idx -eq 0 ]] && first_item="$escaped"
    idx=$((idx + 1))
  done

  local prompt
  prompt=$(printf '%s' "Multiple Apple Passwords records for ${domain}. Select:" | sed 's/\\/\\\\/g; s/"/\\"/g')

  local output
  output=$(
    osascript <<OSASCRIPT
set itemsList to {${osa_list}}
set chosen to choose from list itemsList with prompt "${prompt}" default items {"${first_item}"} without multiple selections allowed
if chosen is false then return "__CANCELLED__"
return item 1 of chosen
OSASCRIPT
  )

  if [[ "$output" == "__CANCELLED__" ]]; then
    log "User cancelled record selection"
    printf '__CANCELLED__'
    return 0
  fi

  # Find selected record
  local i=0
  for display in "${displays[@]}"; do
    if [[ "$display" == "$output" ]]; then
      printf '%s' "${entries[$i]}"
      return 0
    fi
    i=$((i + 1))
  done

  # Fallback to first
  log "Match not found for selection, using first record"
  printf '%s' "${entries[0]}"
}

# ========== Main logic ==========

# Query password list
LIST_JSON=$(query_apw_list "$DOMAIN_LOWER")
LIST_STATUS=$?

if [[ $LIST_STATUS -eq 3 ]]; then
  send_message error "No Apple Passwords records for $DOMAIN"
  log "Exit: no records"
  exit 0
fi

if [[ $LIST_STATUS -ne 0 ]]; then
  die "apw pw list exited with code $LIST_STATUS"
fi

# Parse results
RESULTS=()
while IFS=$'\t' read -r username service label uuid; do
  [[ -z "$username" && -z "$service" ]] && continue
  printf -v entry '%s\t%s\t%s\t%s' "$username" "${service:-$DOMAIN_LOWER}" "$label" "$uuid"
  RESULTS+=("$entry")
done < <(printf '%s' "$LIST_JSON" | jq -r --arg domain "$DOMAIN_LOWER" '
    .results[]? |
    [
        (.username // .user // .account // .email // ""),
        (.domain // .service // .website // .url // .title // $domain),
        (.name // .title // .label // .displayName // ""),
        (.uuid // .id // .identifier // "")
    ] | @tsv
')

log "Found records: ${#RESULTS[@]}"

if [[ ${#RESULTS[@]} -eq 0 ]]; then
  send_message error "No Apple Passwords records for $DOMAIN"
  log "Exit: empty result array after parsing"
  exit 0
fi

# Select record
SELECTED=""
if [[ ${#RESULTS[@]} -eq 1 && $PICK_MODE == false ]]; then
  SELECTED="${RESULTS[0]}"
  log "Automatically selected single record"
else
  # Use fzf with fallback to osascript
  SELECTED=$(select_entry_fzf "$DOMAIN" "${RESULTS[@]}")
  if [[ "$SELECTED" == "__CANCELLED__" ]]; then
    send_message info "Apple Passwords record selection cancelled"
    log "Exit: user cancelled selection"
    exit 0
  fi
fi

IFS=$'\t' read -r USERNAME SERVICE LABEL _uuid <<<"$SELECTED"
log "Selected record: username=$USERNAME, service=$SERVICE, label=$LABEL"

# ========== Form type detection ==========
detect_form_type

# Variable initialization
PASSWORD=""
OTP=""

# ========== Conditional password fetch ==========
if [[ "$HAS_PASSWORD" == "true" ]]; then  # pragma: allowlist secret
  log "Form contains password field, requesting password for $SERVICE"
  GET_JSON=$(query_apw_get "$SERVICE" "$USERNAME")
  PASSWORD=$(printf '%s' "$GET_JSON" | jq -r '.results[0].password // empty' 2>/dev/null)

  if [[ -z "$PASSWORD" ]]; then
    die "apw returned no password (empty value)"
  fi

  log "Password successfully retrieved, length: ${#PASSWORD} chars"

  # If username not specified, try to extract from result
  if [[ -z "$USERNAME" ]]; then
    USERNAME=$(printf '%s' "$GET_JSON" | jq -r '.results[0].username // empty' 2>/dev/null)
    log "Username extracted from apw pw get result: $USERNAME"
  fi
else
  log "Form does NOT contain password field, skipping password request"
fi

# ========== Conditional OTP fetch ==========
if [[ "$HAS_OTP" == "true" ]]; then
  log "Form contains OTP field, requesting OTP for $SERVICE"

  set +e
  OTP_JSON=$(query_apw_otp "$SERVICE")
  OTP_STATUS=$?
  set -e

  if [[ $OTP_STATUS -eq 0 ]]; then
    # OTP successfully retrieved
    OTP=$(printf '%s' "$OTP_JSON" | jq -r '.results[0].code // empty' 2>/dev/null)
    if [[ -n "$OTP" ]]; then
      log "OTP successfully retrieved: $OTP"
    else
      log "OTP JSON retrieved but code is empty"
    fi
  elif [[ $OTP_STATUS -eq 3 ]]; then
    # No OTP for this record (normal)
    log "No OTP for this record (status=3)"
  else
    # Error getting OTP (not critical, continuing without OTP)
    log "Error getting OTP (status=$OTP_STATUS), continuing without OTP"
  fi
else
  log "Form does NOT contain OTP field, skipping OTP request"
fi

# ========== Check that we got something ==========
if [[ -z "$PASSWORD" && -z "$OTP" ]]; then
  die "Failed to get password or OTP for $SERVICE (hasPassword=$HAS_PASSWORD, hasOTP=$HAS_OTP)"
fi

# ========== Generate and inject JavaScript ==========
TMP_JS=$(mktemp /tmp/qute-keychain-login.XXXXXX.js)
trap 'rm -f "$TMP_JS"' EXIT

log "Generating JavaScript for DOM injection"

QUTE_USERNAME="$USERNAME" \
  QUTE_PASSWORD="$PASSWORD" \
  QUTE_OTP="$OTP" \
  QUTE_SERVICE="$SERVICE" \
  QUTE_LABEL="$LABEL" \
  python3 - <<'PYSCRIPT' >"$TMP_JS"
import os, json
from string import Template

username = os.environ.get('QUTE_USERNAME', '')
password = os.environ.get('QUTE_PASSWORD', '')
otp = os.environ.get('QUTE_OTP', '')
service = os.environ.get('QUTE_SERVICE', '')
label = os.environ.get('QUTE_LABEL', '')

template = Template('''
(function() {
  const username = $username;
  const password = $password;
  const otp = $otp;
  const hasUsername = username.length > 0;
  const hasOtp = otp.length > 0;
  const service = $service;
  const label = $label;

  const usernameSelectors = [
    'input[type="email"]',
    'input[type="text"][name*="user" i]:not([name*="otp" i]):not([name*="code" i]):not([name*="token" i]):not([name*="verify" i]):not([inputmode="numeric"])',
    'input[type="text"][name*="email" i]:not([name*="code" i]):not([name*="verify" i])',
    'input[type="text"][name*="login" i]:not([name*="code" i]):not([name*="token" i])',
    'input[autocomplete="username"]',
    'input[autocomplete="email"]',
    'input[name="username"]',
    'input[name="email"]',
    'input[name="login"]',
    'input[name="log"]',
    'input[id*="user" i]:not([id*="otp" i]):not([id*="code" i]):not([id*="verify" i]):not([inputmode="numeric"])',
    'input[id*="email" i]:not([id*="code" i]):not([id*="verify" i])',
    'input[id*="login" i]:not([id*="code" i]):not([id*="token" i])',
    'input[id="user_login"]'
  ];

  const passwordSelectors = [
    'input[type="password"]',
    'input[autocomplete="current-password"]',
    'input[name="password"]',
    'input[name="pwd"]',
    'input[id*="pass" i]',
    'input[id="user_pass"]'
  ];

  const otpSelectors = [
    'input[type="text"][name*="otp" i]',
    'input[type="text"][name*="code" i]',
    'input[type="text"][name*="token" i]',
    'input[type="tel"][name*="code" i]',
    'input[type="number"][name*="code" i]',
    'input[autocomplete="one-time-code"]',
    'input[name="otp"]',
    'input[name="code"]',
    'input[name="token"]',
    'input[name="verification_code"]',
    'input[name="authenticator_code"]',
    'input[id*="otp" i]',
    'input[id*="code" i]',
    'input[id*="token" i]',
    'input[inputmode="numeric"]',
    'input[placeholder*="code" i]',
    'input[placeholder*="code" i]',
    'input[placeholder*="otp" i]',
    'input[name*="2fa" i]',
    'input[name*="mfa" i]',
    'input[id*="2fa" i]',
    'input[id*="mfa" i]',
    'input[name*="verify" i]',
    'input[name*="verification" i]',
    'input[id*="verify" i]',
    'input[placeholder*="verification" i]',
    'input[name*="totp" i]',
    'input[id*="totp" i]',
    'input[name*="sms" i]',
    'input[id*="sms" i]',
    'input[aria-label*="code" i]',
    'input[aria-label*="otp" i]',
    'input[aria-label*="verification" i]',
    'input[name*="pin" i]',
    'input[id*="pin" i]'
  ];

  const events = ['input', 'change', 'keyup'];

  const setValue = (field, value) => {
    if (!field) return false;

    try {
      const proto = Object.getPrototypeOf(field) || HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(proto, 'value');
      if (descriptor && descriptor.set) {
        descriptor.set.call(field, value);
      } else {
        field.value = value;
      }
    } catch (e) {
      field.value = value;
    }

    field.setAttribute('value', value);

    for (const evt of events) {
      field.dispatchEvent(new Event(evt, { bubbles: true }));
    }

    return true;
  };

  const run = () => {
    let filled = 0;
    let usernameField = null;
    let passwordField = null;

    // Find and fill username field
    if (hasUsername) {
      for (const selector of usernameSelectors) {
        const field = document.querySelector(selector);
        if (field && field.offsetParent !== null && !field.disabled && !field.readOnly) {
          usernameField = field;
          break;
        }
      }

      if (usernameField && setValue(usernameField, username)) {
        usernameField.focus();
        filled++;
      }
    }

    // Find and fill password field (only if password retrieved)
    if (password.length > 0) {
      for (const selector of passwordSelectors) {
        const field = document.querySelector(selector);
        if (field && field.offsetParent !== null && !field.disabled && !field.readOnly) {
          passwordField = field;
          break;
        }
      }

      if (passwordField && setValue(passwordField, password)) {
        if (!hasUsername) {
          passwordField.focus();
        }
        filled++;
      }
    }

    // Find and fill OTP field
    let otpField = null;
    if (hasOtp) {
      for (const selector of otpSelectors) {
        const field = document.querySelector(selector);
        if (field && field.offsetParent !== null && !field.disabled && !field.readOnly) {
          otpField = field;
          break;
        }
      }

      if (otpField && setValue(otpField, otp)) {
        otpField.focus();
        filled++;
      }
    }

    // Page notification
    const notification = document.createElement('div');
    notification.style.cssText = 'position:fixed;top:20px;right:20px;padding:15px 20px;border-radius:8px;z-index:10000;font-family:-apple-system,system-ui,sans-serif;font-size:14px;box-shadow:0 4px 12px rgba(0,0,0,0.3);max-width:360px;';

    let infoLine = service || '';
    if (label && label !== service) {
      infoLine = infoLine ? infoLine + ' ‚Ä¢ ' + label : label;
    }

    // Determine expected field count
    let expectedFields = 0;
    if (hasUsername) expectedFields++;
    if (password.length > 0) expectedFields++;
    if (hasOtp) expectedFields++;

    if (filled === expectedFields && filled > 0) {
      // All filled successfully
      notification.style.background = '#4CAF50';
      notification.style.color = 'white';
      let heading = 'üîê Apple Passwords';
      if (hasUsername && hasOtp) {
        heading += ': ' + username + ' + OTP';
      } else if (hasUsername) {
        heading += ': ' + username;
      } else if (hasOtp) {
        heading += ': OTP filled';
      }
      const subtitle = infoLine ? '<br><small>' + infoLine + '</small>' : '';
      notification.innerHTML = heading + subtitle;
    } else if (filled > 0) {
      // Partial fill
      notification.style.background = '#FF9800';
      notification.style.color = 'white';
      notification.innerHTML = '‚ö†Ô∏è Filled fields: ' + filled + ' of ' + expectedFields;
    } else {
      // Nothing filled
      notification.style.background = '#f44336';
      notification.style.color = 'white';
      notification.innerHTML = '‚ùå Input fields not found on page';
    }

    document.body.appendChild(notification);

    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 6000);

    return filled;
  };

  // Wait for DOM load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', run, { once: true });
    return 'Apple Passwords autofill: waiting for DOMContentLoaded';
  }

  const filledCount = run();
  return 'Apple Passwords autofill: filled ' + filledCount + ' fields';
})();
''')

js = template.substitute(
    username=json.dumps(username),
    password=json.dumps(password),
    otp=json.dumps(otp),
    service=json.dumps(service),
    label=json.dumps(label),
)

print(js)
PYSCRIPT

log "JavaScript generated, size: $(wc -c <"$TMP_JS") bytes"

# Inject into page
echo "jseval --quiet --file $TMP_JS" >>"$QUTE_FIFO"

# Final notification
INFO_LINE=""
if [[ -n "$USERNAME" ]]; then
  INFO_LINE="$USERNAME"
  [[ -n "$SERVICE" ]] && INFO_LINE+=" ‚Ä¢ $SERVICE"
  [[ -n "$LABEL" && "$LABEL" != "$SERVICE" ]] && INFO_LINE+=" ‚Ä¢ $LABEL"
else
  INFO_LINE="${SERVICE:-$DOMAIN}"
  [[ -n "$LABEL" && "$LABEL" != "$SERVICE" ]] && INFO_LINE+=" ‚Ä¢ $LABEL"
fi

send_message info "Apple Passwords: $INFO_LINE"
log "Successful completion: $INFO_LINE"
log "========== End session =========="
